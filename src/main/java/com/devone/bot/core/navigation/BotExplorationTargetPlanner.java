
/**
 * BotExplorationTargetPlanner.java
 *
 * Strategic target planning utility for Minecraft bot navigation.
 * Supports adaptive and evenly distributed exploration strategies.
 *
 * @author ChatGPT
 * @version 1.0
 * @since 2025-04-07
 * @generated by ChatGPT on request of Madckoy
 */

 package com.devone.bot.core.navigation;

 import com.devone.bot.utils.BotBlockData;
 import com.devone.bot.utils.BotCoordinate3D;
 
 import java.util.*;
 import java.util.stream.Collectors;
 
 public class BotExplorationTargetPlanner {
 
     public enum Strategy {
         ADAPTIVE_SECTOR,
         EVEN_DISTRIBUTED
     }
 
     public static List<BotBlockData> selectTargets(BotCoordinate3D bot,
                                                    List<BotBlockData> reachable,
                                                    Strategy strategy,
                                                    int sectorCount,
                                                    int maxTargets,
                                                    boolean preferDistant,
                                                    int scanRadius) {
 
         if (reachable == null || reachable.isEmpty()) return null;
 
         switch (strategy) {
             case ADAPTIVE_SECTOR:
                 return selectAdaptiveSectorTargets(reachable, bot, sectorCount);
             case EVEN_DISTRIBUTED:
                 return findEvenlyDistributedTargets(reachable, bot, sectorCount, maxTargets, preferDistant, scanRadius);
             default:
                 return null;
         }
     }
 
     private static List<BotBlockData> selectAdaptiveSectorTargets(List<BotBlockData> reachable, BotCoordinate3D bot, int sectorCount) {
         Map<Integer, BotBlockData> bestInSector = new HashMap<>();
         Map<Integer, Double> maxDistances = new HashMap<>();
 
         for (BotBlockData point : reachable) {
             int dx = point.x - bot.x;
             int dz = point.z - bot.z;
 
             if (dx == 0 && dz == 0) continue;
 
             double angle = Math.atan2(dz, dx);
             int sector = (int) ((angle + Math.PI) / (2 * Math.PI) * sectorCount) % sectorCount;
 
             double distanceSq = dx * dx + dz * dz;
 
             if (!maxDistances.containsKey(sector) || distanceSq > maxDistances.get(sector)) {
                 bestInSector.put(sector, point);
                 maxDistances.put(sector, distanceSq);
             }
         }
 
         return new ArrayList<>(bestInSector.values());
     }
 
     private static List<BotBlockData> findEvenlyDistributedTargets(
             List<BotBlockData> reachable,
             BotCoordinate3D bot,
             int sectors,
             int maxTargets,
             boolean preferDistant,
             int scanRadius) {
 
         double minRadius = Math.max(2.0, scanRadius * 1.0);
         Map<Integer, BotBlockData> sectorMap = new HashMap<>();
 
         for (BotBlockData point : reachable) {
             if (point.x == bot.x && point.z == bot.z) continue;
 
             double dx = point.x - bot.x;
             double dy = point.y - bot.y;
             double dz = point.z - bot.z;
             double distSq = dx * dx + dy * dy + dz * dz;
             double dist = Math.sqrt(distSq);
             if (dist < minRadius) continue;
 
             double angle = Math.atan2(dz, dx);
             int sector = (int) ((angle + Math.PI) / (2 * Math.PI) * sectors) % sectors;
 
             BotBlockData current = sectorMap.get(sector);
 
             if (current == null ||
                     (preferDistant && distSq > squaredDistance(current, bot)) ||
                     (!preferDistant && distSq < squaredDistance(current, bot))) {
                 sectorMap.put(sector, point);
             }
         }
 
         return sectorMap.values().stream()
                 .sorted(Comparator.comparingDouble(p -> -squaredDistance(p, bot)))
                 .limit(maxTargets)
                 .collect(Collectors.toList());
     }
 
     private static double squaredDistance(BotBlockData point, BotCoordinate3D bot) {
         return Math.pow(point.x - bot.x, 2) + Math.pow(point.y - bot.y, 2) + Math.pow(point.z - bot.z, 2);
     }
 }
 