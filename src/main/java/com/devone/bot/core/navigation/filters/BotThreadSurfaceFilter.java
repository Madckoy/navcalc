
/**
 * BotThreadSurfaceFilter.java
 *
 * Surface filtering algorithm for Minecraft bots navigating voxel terrain.
 * Filters blocks based on air presence above, allowing bots to find safe walkable paths.
 *
 * ‚ñë‚ñí‚ñì‚ñí‚ñë Created with care by ChatGPT ‚ñë‚ñí‚ñì‚ñí‚ñë
 * üí° Designed in collaboration with Madckoy ‚Äî a true code artisan.
 * @generated by ChatGPT on request of Madckoy
 * @version 1.0
 * @since 2025-04-07
 */

 package com.devone.bot.core.navigation.filters;

 import com.devone.bot.utils.BlockMaterialUtils;
 import com.devone.bot.utils.BotBlockData;
 
 import java.util.*;
 
 public class BotThreadSurfaceFilter {
 
     /**
      * –ú—É–ª—å—Ç–∏–ø—Ä–æ—Ö–æ–¥ –ø–æ —Å–ª–æ—è–º Y: –æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –±–ª–æ–∫–∏, –Ω–∞–¥ –∫–æ—Ç–æ—Ä—ã–º–∏ –µ—Å—Ç—å –¥–≤–∞ —É—Ä–æ–≤–Ω—è –≤–æ–∑–¥—É—Ö–∞
      * –∏–ª–∏ –Ω–∏—á–µ–≥–æ (—á—Ç–æ —Ç—Ä–∞–∫—Ç—É–µ—Ç—Å—è –∫–∞–∫ –ø—É—Å—Ç–æ—Ç–∞).
      */
     public static List<BotBlockData> filterWalkableSurfaceBlocks(List<BotBlockData> blocks) {
         Map<String, BotBlockData> blockMap = new HashMap<>();
         for (BotBlockData block : blocks) {
             String key = block.x + "," + block.y + "," + block.z;
             blockMap.put(key, block);
         }
 
         List<BotBlockData> result = new ArrayList<>();
 
         for (BotBlockData block : blocks) {
             int x = block.x;
             int y = block.y;
             int z = block.z;
 
             String key1 = x + "," + (y + 1) + "," + z;
             String key2 = x + "," + (y + 2) + "," + z;
 
             boolean airAbove1 = !blockMap.containsKey(key1) || BlockMaterialUtils.isAir(blockMap.get(key1).type);
             boolean airAbove2 = !blockMap.containsKey(key2) || BlockMaterialUtils.isAir(blockMap.get(key2).type);
 
             if (airAbove1 && airAbove2) {
                 result.add(block);
             }
         }
 
         return result;
     }
 
     /**
      * –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö –±–ª–æ–∫–æ–≤, –ø—Ä–∏–≥–æ–¥–Ω—ã—Ö –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è:
      * - —Ä–∞–±–æ—Ç–∞–µ—Ç —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
      * - –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ—Ç –±–ª–æ–∫–∏, –Ω–∞–¥ –∫–æ—Ç–æ—Ä—ã–º–∏ –Ω–µ—Ç 2-—Ö —É—Ä–æ–≤–Ω–µ–π –≤–æ–∑–¥—É—Ö–∞ (–∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –¥–∞–Ω–Ω—ã–µ)
      * - –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç –±–ª–æ–∫–∏, –ø–µ—Ä–µ–∫—Ä—ã—Ç—ã–µ –ø–ª–æ—Ç–Ω–æ–π –º–∞—Å—Å–æ–π (–µ—Å–ª–∏ –≤–æ–∑–¥—É—Ö —Å–∫—Ä—ã—Ç)
      */
     public static List<BotBlockData> filterWalkableSurfaceBlocksComplex(List<BotBlockData> blocks) {
         Map<String, BotBlockData> blockMap = new HashMap<>();
         for (BotBlockData block : blocks) {
             String key = block.x + "," + block.y + "," + block.z;
             blockMap.put(key, block);
         }
 
         // –°–æ–±–∏—Ä–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —É—Ä–æ–≤–Ω–∏ Y
         Set<Integer> allY = new TreeSet<>();
         for (BotBlockData block : blocks) {
             allY.add(block.y);
         }
 
         // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ XZ –¥–ª—è –ø–ª–æ—Ç–Ω–æ—Å—Ç–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
         Map<String, List<BotBlockData>> columns = new HashMap<>();
         for (BotBlockData block : blocks) {
             String colKey = block.x + "," + block.z;
             columns.computeIfAbsent(colKey, k -> new ArrayList<>()).add(block);
         }
 
         List<BotBlockData> result = new ArrayList<>();
 
         for (Map.Entry<String, List<BotBlockData>> entry : columns.entrySet()) {
             List<BotBlockData> column = entry.getValue();
             column.sort(Comparator.comparingInt(b -> b.y)); // –°–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
 
             for (BotBlockData block : column) {
                 int x = block.x;
                 int y = block.y;
                 int z = block.z;
 
                 String key1 = x + "," + (y + 1) + "," + z;
                 String key2 = x + "," + (y + 2) + "," + z;
 
                 boolean airAbove1 = !blockMap.containsKey(key1) || BlockMaterialUtils.isAir(blockMap.get(key1).type);
                 boolean airAbove2 = !blockMap.containsKey(key2) || BlockMaterialUtils.isAir(blockMap.get(key2).type);
 
                 if (airAbove1 && airAbove2) {
                     result.add(block);
                 }
             }
         }
 
         return result;
     }
 }
 