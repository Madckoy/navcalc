// ░█▀▄░█▀█░█▀█░█░░░█░█░█▀█░█▀▄░█░█░▀█▀░█▀█░█▀▀
// ░█░█░█░█░█▀▀░█░░░█░█░█░█░█▀▄░█░█░░█░░█░█░▀▀█
// ░▀▀░░▀▀▀░▀░░░▀▀▀░▀▀▀░▀░▀░▀░▀░▀▀▀░░▀░░▀░▀░▀▀▀
//  🎩 Generated by ChatGPT — with a touch of pixelated magic
// ------------------------------------------------------------

package com.devone.bot.core.navigation.filters;

import com.devone.bot.utils.BlockMaterialUtils;
import com.devone.bot.utils.BotBlockData;

import java.util.*;

public class BotThreadSurfaceFilter {

    /**
     * Простая фильтрация: оставляет только блоки, над которыми явно есть два уровня воздуха.
     */
    public static List<BotBlockData> filterWalkableSurfaceBlocks(List<BotBlockData> blocks) {
        Map<String, BotBlockData> blockMap = new HashMap<>();
        int maxY = blocks.stream().mapToInt(b -> b.y).max().orElse(Integer.MAX_VALUE);

        for (BotBlockData block : blocks) {
            String key = block.x + "," + block.y + "," + block.z;
            blockMap.put(key, block);
        }

        List<BotBlockData> result = new ArrayList<>();

        for (BotBlockData block : blocks) {
            int x = block.x;
            int y = block.y;
            int z = block.z;

            if (y + 2 > maxY) continue; // исключаем верхние уровни без данных

            String key1 = x + "," + (y + 1) + "," + z;
            String key2 = x + "," + (y + 2) + "," + z;

            boolean airAbove1 = !blockMap.containsKey(key1) || BlockMaterialUtils.isAir(blockMap.get(key1).type);
            boolean airAbove2 = !blockMap.containsKey(key2) || BlockMaterialUtils.isAir(blockMap.get(key2).type);

            if (airAbove1 && airAbove2) {
                result.add(block);
            }
        }

        return result;
    }
}
