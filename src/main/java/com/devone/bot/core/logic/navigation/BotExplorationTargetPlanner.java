
/**
 * BotExplorationTargetPlanner.java
 *
 * Strategic target planning utility for Minecraft bot navigation.
 * Supports adaptive and evenly distributed exploration strategies.
 *
 * @author ChatGPT
 * @version 1.0
 * @since 2025-04-07
 * @generated by ChatGPT on request of Madckoy
 */

 package com.devone.bot.core.logic.navigation;

 import com.devone.bot.utils.blocks.BotBlockData;
import com.devone.bot.utils.blocks.BotCoordinate3D;

import java.util.*;
 import java.util.stream.Collectors;
 
 public class BotExplorationTargetPlanner {
 
     public enum Strategy {
         ADAPTIVE_SECTOR,
         EVEN_DISTRIBUTED
     }
 
     public static List<BotBlockData> selectTargets(BotCoordinate3D bot,
                                                    List<BotBlockData> reachable,
                                                    Strategy strategy,
                                                    int sectorCount,
                                                    int maxTargets,
                                                    boolean preferDistant,
                                                    int scanRadius) {
 
         if (reachable == null || reachable.isEmpty()) return null;
 
         switch (strategy) {
             case ADAPTIVE_SECTOR:
                 return selectAdaptiveSectorTargets(reachable, bot, sectorCount);
             case EVEN_DISTRIBUTED:
                 return findEvenlyDistributedTargets(reachable, bot, sectorCount, maxTargets, preferDistant, scanRadius);
             default:
                 return null;
         }
     }
 
     private static List<BotBlockData> selectAdaptiveSectorTargets(List<BotBlockData> reachable, BotCoordinate3D bot, int sectorCount) {
         Map<Integer, BotBlockData> bestInSector = new HashMap<>();
         Map<Integer, Double> maxDistances = new HashMap<>();
 
         for (BotBlockData point : reachable) {
             int dx = point.x - bot.x;
             int dz = point.z - bot.z;
 
             if (dx == 0 && dz == 0) continue;
 
             double angle = Math.atan2(dz, dx);
             int sector = (int) ((angle + Math.PI) / (2 * Math.PI) * sectorCount) % sectorCount;
 
             double distanceSq = dx * dx + dz * dz;
 
             if (!maxDistances.containsKey(sector) || distanceSq > maxDistances.get(sector)) {
                 bestInSector.put(sector, point);
                 maxDistances.put(sector, distanceSq);
             }
         }
 
         return new ArrayList<>(bestInSector.values());
     }
 
     private static List<BotBlockData> findEvenlyDistributedTargets(
        List<BotBlockData> reachable,
        BotCoordinate3D bot,
        int sectors,
        int maxTargetsInput,
        boolean preferDistant,
        int scanRadius) {

    if (reachable == null || reachable.isEmpty()) return List.of();

    // üìê –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π maxTargets
    int maxTargets = estimateAdaptiveMaxTargets(reachable, scanRadius);
    if (maxTargets == 0) return List.of();

    double minRadius = (scanRadius > 3) ? scanRadius * 0.5 : 0.0;
    Map<Integer, BotBlockData> sectorMap = new HashMap<>();

    for (BotBlockData point : reachable) {
        if (point.x == bot.x && point.z == bot.z) continue;

        double dx = point.x - bot.x;
        double dy = point.y - bot.y;
        double dz = point.z - bot.z;
        double distSq = dx * dx + dy * dy + dz * dz;
        double dist = Math.sqrt(distSq);

        if (dist < minRadius) continue;

        double angle = Math.atan2(dz, dx);
        int sector = (int) ((angle + Math.PI) / (2 * Math.PI) * sectors) % sectors;

        BotBlockData current = sectorMap.get(sector);

        if (current == null ||
                (preferDistant && distSq > squaredDistance(current, bot)) ||
                (!preferDistant && distSq < squaredDistance(current, bot))) {
            sectorMap.put(sector, point);
        }
    }

    // üß± Fallback: –¥–æ–±–∏—Ä–∞–µ–º —Å–∞–º—ã–µ —É–¥–∞–ª—ë–Ω–Ω—ã–µ
    if (sectorMap.size() < maxTargets) {
        reachable.stream()
                .filter(p -> !sectorMap.containsValue(p))
                .sorted(Comparator.comparingDouble(p -> -squaredDistance(p, bot)))
                .limit(maxTargets - sectorMap.size())
                .forEach(p -> sectorMap.put(sectorMap.size() + 1000, p));
    }

    // üéØ –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–º—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é –º–µ–∂–¥—É —Ü–µ–ª—è–º–∏
    List<BotBlockData> filtered = filterByDistance(
            sectorMap.values().stream()
                    .sorted(Comparator.comparingDouble(p -> -squaredDistance(p, bot)))
                    .collect(Collectors.toList()),
            3.0  // –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –º–µ–∂–¥—É —Ü–µ–ª—è–º–∏
    );

    return filtered.stream()
            .limit(maxTargets)
            .collect(Collectors.toList());
}



    private static int estimateAdaptiveMaxTargets(List<BotBlockData> reachable, int scanRadius) {
        if (reachable == null || reachable.isEmpty()) return 0;
    
        double area = Math.PI * scanRadius * scanRadius;
        double densityFactor = 0.8;
    
        int suggested = (int) Math.round(Math.min(reachable.size(), area * densityFactor));
        return Math.max(1, Math.min(suggested, reachable.size()));
    }
    
    private static double squaredDistance(BotBlockData a, BotCoordinate3D b) {
        return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2) + Math.pow(a.z - b.z, 2);
    }
    
    private static List<BotBlockData> filterByDistance(List<BotBlockData> candidates, double minDist) {
        List<BotBlockData> result = new ArrayList<>();
        for (BotBlockData candidate : candidates) {
            boolean tooClose = result.stream()
                    .anyMatch(p -> squaredDistance(p, candidate) < minDist * minDist);
            if (!tooClose) {
                result.add(candidate);
            }
        }
        return result;
    }
 }
 